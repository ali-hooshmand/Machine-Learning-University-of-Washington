# coding=utf-8# TASKS:================================================================================================================# In this notebook we will cover estimating multiple regression weights via gradient descent (GD). You will:# 1- Add a constant column of 1's to a SFrame (or otherwise) to account for the intercept# 2- Convert an SFrame into a numpy array# 3- Write a predict_output() function using numpy# 4- Write a numpy function to compute the derivative of the regression weights with respect to a single feature# 5- Write GD function to compute the regression weights given an initial weight vector, step size and tolerance.# 6- Use the gradient descent function to estimate regression weights for multiple features# ======================================================================================================================# coding=utf-8import pandasimport numpy as npimport timeimport math# from sklearn import linear_modelstart = time.time()# 1 & 2. load in the house datasales = pandas.read_csv('./kc_house_data.csv')sales_train = pandas.read_csv('./kc_house_train_data.csv')sales_test = pandas.read_csv('./kc_house_test_data.csv')# ======================================================================================================================# 3. Next write a function that takes a data set, a list of features (e.g. [‘sqft_living’, ‘bedrooms’]), to be used as# inputs, and a name of the output (e.g. ‘price’). This function should return a features_matrix (2D array) consisting# of first a column of ones followed by columns containing the values of the input features in the data set in the same# order as the input list. It should also return an output_array which is an array of the values of the output in the# data set (e.g. ‘price’):def get_numpy_data(data, features, output):    data['constant'] = 1  # add a constant column to an SFrame    # prepend variable 'constant' to the features list    features = ['constant'] + features    # select the columns of data_SFrame given by the ‘features’ list into the SFrame ‘features_sframe’    features_data = data[features]    # this will convert the features_data into a numpy matrix    features_matrix = np.asarray(features_data)    # assign the column of data_sframe associated with the target to the variable ‘output_sarray’    output_data = data[output]    # this will convert the SArray into a numpy array:    output_array = np.asarray(output_data)    return(features_matrix, output_array)# ======================================================================================================================# 4. If the features matrix (including a column of 1s for the constant) is stored as a 2D array (or matrix) and the# regression weights are stored as a 1D array then the predicted output is just the dot product between the features# matrix and the weights (with the weights on the right). Write a function ‘predict_output’ which accepts a 2D array# ‘feature_matrix’ and a 1D array ‘weights’ and returns a 1D array ‘predictions’. e.g. in python:def predict_outcome(feature_matrix, weights):    predictions = feature_matrix.dot(weights)    return(predictions)# ======================================================================================================================# 5. If we have a the values of a single input feature in an array ‘feature’ and the prediction ‘errors’ (predictions -# output) then the derivative of the regression cost function with respect to the weight of ‘feature’ is just twice the# dot product between ‘feature’ and ‘errors’. Write a function that accepts a ‘feature’ array and ‘error’ array and# returns the ‘derivative’ (a single number). e.g. in python:def feature_derivative(errors, feature):    derivative = 2 * errors.dot(feature)    return(derivative)# ======================================================================================================================# 6. Now we will use our predict_output and feature_derivative to write a gradient descent function. Although we can# compute the derivative for all the features simultaneously (the gradient) we will explicitly loop over the features# individually for simplicity. Write a gradient descent function that does the following:# - Accepts a numpy feature_matrix 2D array, a 1D output array, an array of initial weights, a step size and a#   convergence tolerance.# - While not converged updates each feature weight by subtracting the step size times the derivative for that feature#   given the current weights# - At each step computes the magnitude/length of the gradient (square root of the sum of squared components)# - When the magnitude of the gradient is smaller than the input tolerance returns the final weight vector.# e.g. if you’re using SFrames and numpy you can complete the following function:def regression_gradient_descent(feature_matrix, output, initial_weights, step_size, tolerance):    converged = False    weights = np.array(initial_weights)    gradient_magnitude = 0    while not converged:        # compute the predictions based on feature_matrix and weights:        predictions = predict_outcome(feature_matrix, weights)        # compute the errors as predictions - output:        errors = predictions - output        gradient_sum_squares = 0  # initialize the gradient        # while not converged, update each weight individually:        for i in range(len(weights)):            # Recall that feature_matrix[:, i] is the feature column associated with weights[i]            # compute the derivative for weight[i]:            derivative = feature_derivative(errors, feature_matrix[:, i])            # add the squared derivative to the gradient magnitude            gradient_sum_squares += derivative * derivative            # update the weight based on step size and derivative:            weights[i] -= step_size * derivative        gradient_magnitude = math.sqrt(gradient_sum_squares)        if gradient_magnitude < tolerance:            converged = True    return (weights)# ======================================================================================================================# 7. Now split the sales data into training and test data.# DONE above!# ======================================================================================================================# 8. Now we will run the regression_gradient_descent function on some actual data. In particular we will use the# gradient descent to estimate the model from Week 1 using just an intercept and slope. Use the following parameters:# - features: ‘sqft_living’# - output: ‘price’# - initial weights: -47000, 1 (intercept, sqft_living respectively)# - step_size = 7e-12# - tolerance = 2.5e7simple_features = ['sqft_living']my_output = 'price'(features_matrix, output_array) = get_numpy_data(sales_train, simple_features, my_output)initial_weights = np.array([-47000.0, 1.0])step_size = 7e-12tolerance = 2.5e7simple_weights = regression_gradient_descent(features_matrix, output_array, initial_weights, step_size, tolerance)# ======================================================================================================================# 9. Quiz Question: What is the value of the weight for sqft_living -- the second element of ‘simple_weights’?print simple_weights[0]  # -46999.8871655print simple_weights[1]  # 281.912119175# ======================================================================================================================# 10. Now build a corresponding ‘test_simple_feature_matrix’ and ‘test_output’ using test_data.# Using ‘test_simple_feature_matrix’ and ‘simple_weights’ compute the predicted house prices on all the test data.(test_simple_feature_matrix, test_output) = get_numpy_data(sales_test, simple_features, my_output)test_predictions = predict_outcome(test_simple_feature_matrix, simple_weights)# ======================================================================================================================# 11. Quiz Question: What is the predicted price for the 1st house in the Test data set for model 1?print 'The predicted price for the 1st house in the Test data set is $'+str(round(test_predictions[0], 0))  # $356134.0# ======================================================================================================================# 12. Now compute RSS on all test data for this model. Record the value and store it for laterrss_test = (test_predictions - test_output).dot(test_predictions - test_output)  # 2.75400044902e+14# ======================================================================================================================# 13. Now we will use the gradient descent to fit a model with more than 1 predictor variable (and an intercept).# Use the following parameters:# - model features = ‘sqft_living’, ‘sqft_living_15’# -  output = ‘price’# - initial weights = [-100000, 1, 1] (intercept, sqft_living, and sqft_living_15 respectively)# - step size = 4e-12# - tolerance = 1e9features = ['sqft_living', 'sqft_living15']my_output = 'price'(features_matrix, output_array) = get_numpy_data(sales_train, features, my_output)initial_weights = np.array([-100000.0, 1.0, 1.0])step_size = 4e-12tolerance = 1e9weights = regression_gradient_descent(features_matrix, output_array, initial_weights, step_size, tolerance)# weights = [-99999.9688489, 245.072603465, 65.2795266989]# ======================================================================================================================# 14. Use the regression weights from this second model (using sqft_living and sqft_living_15) and predict the outcome# of all the house prices on the TEST data.(test_feature_matrix, test_output) = get_numpy_data(sales_test, features, my_output)test_predictions_model2 = predict_outcome(test_feature_matrix, weights)# ======================================================================================================================# 15. Quiz Question: What is the predicted price for the 1st house in the TEST data set for model 2?print 'The predicted price for the 1st house in the Test data set based on model2 is $'+str(round(test_predictions_model2[0], 0))  # $366651.0# ======================================================================================================================# 16. What is the actual price for the 1st house in the Test data set?# 17. Quiz Question: Which estimate was closer to the true price for the 1st house on the TEST data set? Model 1print test_output[0] # $310000# ======================================================================================================================# 18. Now compute RSS on all test data for the second model. Record the value and store it for later.# 19. Quiz Question: Which model (1 or 2) has lowest RSS on all of the TEST data? Answer: Model 2rss_test_model2 = (test_predictions_model2 - test_output).dot(test_predictions_model2 - test_output)  # 2.7026344363e+14print rss_test_model2end = time.time()print('Time of Process was: ' + str(end - start) + '[sec]')